==================
american fuzzy lop
==================

Written and maintained by Michal Zalewski <lcamtuf@google.com>

Copyright 2013 Google Inc. All rights reserved.
Released under terms and conditions of Apache License, Version 2.0.

For new versions and additional information, check out:
http://code.google.com/p/american-fuzzy-lop/

1) Background
-------------

Fuzzing is one of the most powerful methods of detecting software security
problems, but it tends to offer shallow coverage: it is usually impractical
to exhaustively examine all possible inputs and reach all the internal states
of the tested application.

There have been numerous, primarily academic attempts to improve the
penetration of fuzz testing through various types of runtime instrumentation
and static analysis. These techniques can be divided into three broad groups:

  - Simple coverage maximization: selecting test cases or mutations that
    improve the measured coverage of the instrumented code.

  - Control flow analysis: selecting test cases or mutations that exercise
    distinctive code paths in the tested application.

  - Effector analysis: selecting test cases or mutations that are expected
    to produce specific outcomes within the internal state of the program.

The first technique is surprisingly powerful when used to preselect initial
test cases from a large corpus of data. But because it quickly reaches a
plateau, it tends to be less useful for providing continued guidance thoroughout
the fuzzing process.

The last two techniques are extremely promising in experimental settings, but
in real-world applications, they lead to irreducible complexity: almost every
instrumented program has a vast number of internal states and possible
execution paths. Distinguishing between interesting leads and pointless
tarpits is problematic - and without this, instrumented fuzzers are overwhelmed
by the number of generated test cases and usually produce results that are
just marginally better than chance.

2) About AFL
------------

American Fuzzy Lop uses a form of Markov chains to detect subtle, local-scale
changes to program control flow without having to perform a complex comparisons
between series of distinctive traces (a common failure point for other tools).

In essence, the fuzzer instruments every effective line of C or C++ code to
record a tuple in the following format:

  <ID of current code location>, <ID of previously-executed code location>

The ordering or hit count for each tuple is discarded; the only signal used by
the fuzzer is the appearance of a previously-unseen tuple in the output
dataset. This method combines the self-limiting nature of simple coverage
measurements with the sensitivity of control flow analysis.

The instrumentation is used as a part of a simple queue-based algorithm:

0) Load user-supplied initial test cases into the queue,

1) Take input file from the queue,

2) Repeatedly mutate the file using a balanced variety of traditional fuzzing
   strategies,

3) If any of the generated mutations resulted in a new tuple being recorded by
   the instrumentation, add mutated output as a new entry in the queue.

4) If queue not empty, go to 1.

In real-world testing with libraries such as libjpeg, libpng, libtiff, or
giflib, the fuzzer requires no fine-tuning, and significantly outperforms
coverage-only tools.

3) Instrumenting programs for use with AFL
------------------------------------------

Instrumentation is injected by a companion tool called afl-gcc. It is meant to
be used as a drop-in replacement for GCC, directly pluggable into the standard
build process for any third-party code.

The instrumentation has a relatively modest performance impact; for example,
instrumenting gzip slows down the fuzzing process by less than 30%, compared to
non-instrumented code.

The injected probes are designed to work with C and C++ code compiled on 32-bit
x86 platforms. Porting to other platforms, or to binary-only targets, should not
be difficult. There are some "unofficial" 64-bit patches in experimental/64bit.

The correct way to recompile the target program will vary depending on the
specifics of the build process, but a common approach may be:

$ export AFL_PATH=/path/to/afl/
$ CC=$AFL_PATH/afl-gcc ./configure
$ make clean all

For C++ programs, it may be necessary to specify CXX instead of CC. When testing
libraries, it is essential to either link the tested executable against a static
version of the instrumented library (./configure --disable-shared may be
useful), or to use the right LD_LIBRARY_PATH.

Setting AFL_HARDEN in the environment will cause afl-gcc to automatically enable
several GCC hardening feeatures that may make it easier to detect memory bugs;
with GCC 4.8 and above, this includes ASAN / MSAN.

Running 'prelink' against the target binary may offer performance benefits and
has no adverse effects on the instrumentation.

4) Choosing initial test cases
------------------------------

To operate correctly, the fuzzer requires one or more input file containing
a normal, typical input normally processed by the targeted application.

Whenever possible, the file should be reasonably small; under 1 kB is ideal,
although not strictly necessary.

There is limited value in providing multiple files that are not fundamentally
different from each other, and exercise the same set of features. When in
doubt, use fewer samples, not more.

If a large corpus of data is available for screening, the afl-showmap utility
can be employed to compare the instrumentation data recorded for various
inputs. Files that not produce any previously-unseen tuples can be usually
rejected.

5) Fuzzing instrumented binaries
--------------------------------

The fuzzing process itself is carried out by the afl-fuzz utility. The program
requires an input directory containing one or more initial test cases, plus a
path to the binary to test.

For tested programs that accept data on stdin, the usual syntax may be:

$ ./afl-fuzz -i input_dir -o output_dir /path/to/program [...params...]

For programs that need to read data from a specific file, the appropriate
path can be specified via the -f flag.

It is possible to fuzz non-instrumented code using the -n flag. This gives you
a fairly traditional fuzzer with a couple of nice testing strategies.

You can use -t and -m to override the default timeout and memory limit for the
executed process, although this is seldom necessary.

The fuzzing process itself is relatively simple. It consists of several types
of sequential, deterministic operations (bitflips, injection of interesting
integers) followed by a "havoc" stage with multiple stacked, random
modifications - block deletion, cloning, random bitflips, etc.

The deterministic stage takes time proportional to the size of the input file;
once this is done, the havoc stages continue for every discovered input until
Ctrl-C is hit.

For large inputs, or when trying to distribute the fuzzing process, you can
use -d to skip the deterministic stages and proceed straight to random tweaks.

Last but not least, the -u option can be useful if you wish to conserve disk
space: it makes the fuzzer store only the first test case for every distinctive
execution path that led to a crash or a hang. Fuzzing coverage as such is not
affected by this flag.

6) Interpreting output
----------------------

The fuzzer keeps going until aborted with Ctrl-C or killed with SIGINT or
SIGTERM. The progress screen provides various useful stats, including the
number of distinctive execution paths discovered, the current queue cycle,
the number of crashes recorded, and the number of execve() calls per second.

For more info about the displayed data, visit this URL:

  https://code.google.com/p/american-fuzzy-lop/wiki/StatusScreen

There are three subdirectories created within the output directory:

  - queue/ - initial test cases for every distinctive execution path. The data
             may be useful for seeding other fuzzers, for resuming aborted
             fuzzing jobs, or for various manual testing steps.

             Any test cases that inherently result in variable execution paths
             will have "-variable" appended to their filenames.

  - hangs/ - test cases that cause the tested program to time out. The entries
             are grouped by a 32-bit hash of the execution path.

  - crashes/ - test cases that caused the tested program to receive a fatal
               signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are 
               grouped by the received signal, followed by the hash of the
               execution path.

Although the fuzzer does not perform any additional analysis of the discovered
crashes, the path-based grouping makes it easy to triage new finds manually - or
to examine them with a simple GDB script. One such script is provided in
experimental/gdb/.

7) Known limitations & areas for improvement
--------------------------------------------

Here are some of the most important caveats for AFL:

- The fuzzer is optimized for compact binary data formats, such as images
  and other multimedia. It is not well-suited for verbose, human-readable
  formats such as HTML or JavaScript. In such cases, template- or ABNF-based
  generators tend to fare better.

  To modify the code to generate syntax-aware mutations, you'd need to start
  with fuzz_one() in afl-fuzz.c.

- The fuzzer offers limited coverage if encryption, checksums, cryptographic
  signatures, or compression are used to wholly wrap the actual data format
  to be tested.

  Good solutions include manually commenting out the relevant checks in the
  instrumented application, or using a wrapper that postprocesses the
  fuzzer-generated data before feeding it to the target program.

  As an example, a patch for libpng to bypass CRC checksums is provided in 
  experimental/libpng/libpng-nocrc.patch.

- The included instrumentation (afl-as.h) currently supports just 32-bit
  x86 code. An "unofficial" set of patches to support 64-bit code is included
  in experimental/64bit/.

  For other CPUs, rewriting the assembly code in afl-as.h should be a very
  simple task. Note that minor tweaks to fuzz_one() in afl-fuzz.c would be
  necessary to accommodate architectures requiring aligned memory access,
  though.

- The approach is theoretically compatible with any GCC-supported language,
  but only C and C++ were confirmed to work. Objective C is very likely
  to work; reports for other languages (e.g. GCJ Java) are welcome.

- Instrumentation of binary-only code is theoretically possible, but not
  supported at this point. Leveraging pin or DynamoRIO may be a good
  approach.

7) Contact
----------

Questions? Concerns? Bug reports? The author can be usually reached at
<lcamtuf@google.com>.

